{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"docs/","title":"JiWER","text":"<p>Jiwer is a simple and fast python package to evaluate an automatic speech recognition system. It supports the following measures:</p> <ol> <li>word error rate (WER)</li> <li>match error rate (MER)</li> <li>word information lost (WIL) </li> <li>word information preserved (WIP) </li> <li>character error rate (CER)</li> </ol> <p>These measures are computed with the use of the minimum-edit distance between one or more reference and hypothesis sentences. The minimum-edit distance is calculated using RapidFuzz, which uses C++ under the hood, and is therefore faster than a pure python implementation.</p>"},{"location":"docs/#installation","title":"Installation","text":"<p>You should be able to install this package using poetry: </p> <pre><code>$ poetry add jiwer\n</code></pre> <p>Or, if you prefer old-fashioned pip and you're using Python &gt;= <code>3.7</code>:</p> <pre><code>$ pip install jiwer\n</code></pre>"},{"location":"docs/cli/","title":"Command-line interface","text":"<p>JiWER provides a simple CLI, which should be available after installation. </p> <p>For details, see <code>jiwer --help</code>.</p> <pre><code>$ jiwer --help\nUsage: jiwer [OPTIONS]\n\n  JiWER is a python tool for computing the word-error-rate of ASR systems. To\n  use this CLI, store the reference and hypothesis sentences in a text file,\n  where each sentence is delimited by a new-line character. The text files are\n  expected to have an equal number of lines, unless the `-g` flag is used. The\n  `-g` flag joins computation of the WER by doing a global minimal alignment.\n\nOptions:\n  -r, --reference PATH   Path to new-line delimited text file of reference\n                         sentences.  [required]\n  -h, --hypothesis PATH  Path to new-line delimited text file of hypothesis\n                         sentences.  [required]\n  -c, --cer              Compute CER instead of WER.\n  -a, --align            Print alignment of each sentence.\n  -g, --global           Apply a global minimal alignment between reference\n                         and hypothesis sentences before computing the WER.\n  --help                 Show this message and exit.\n</code></pre> <p>Note that the CLI does not support a custom pre-processing (as described below). Any pre-processing should be done on the text files manually before calling JiWER when using the CLI. </p>"},{"location":"docs/usage/","title":"Usage","text":"<p>The most simple use-case is computing the edit distance between two strings:</p> <pre><code>from jiwer import wer\n\nreference = \"hello world\"\nhypothesis = \"hello duck\"\n\nerror = wer(reference, hypothesis)\n</code></pre> <p>Similarly, to get other measures:</p> <pre><code>import jiwer\n\nreference = \"hello world\"\nhypothesis = \"hello duck\"\n\nwer = jiwer.wer(reference, hypothesis)\nmer = jiwer.mer(reference, hypothesis)\nwil = jiwer.wil(reference, hypothesis)\n\n# faster, because `compute_measures` only needs to perform the heavy lifting once:\noutput = jiwer.process_words(reference, hypothesis)\nwer = output.wer\nmer = output.mer\nwil = output.wil\n</code></pre> <p>You can also compute the WER over multiple sentences:</p> <pre><code>from jiwer import wer\n\nreference = [\"hello world\", \"i like monthy python\"]\nhypothesis = [\"hello duck\", \"i like python\"]\n\nerror = wer(reference, hypothesis)\n</code></pre> <p>We also provide the character error rate:</p> <pre><code>import jiwer\n\nreference = [\"i can spell\", \"i hope\"]\nhypothesis = [\"i kan cpell\", \"i hop\"]\n\nerror = jiwer.cer(reference, hypothesis)\n\n# if you also want the alignment\noutput = jiwer.process_characters(reference, hypothesis)\nerror = output.cer\n</code></pre>"},{"location":"docs/usage/#alignment","title":"Alignment","text":"<p>With <code>jiwer.process_words</code>, you also get the alignment between the ground-truth and hypothesis.</p> <p>We provide the alignment as a list of <code>(op, ref_start_idx, ref_idx_end, hyp_idx_start, hyp_idx_end)</code>, where <code>op</code> is one of     <code>equal</code>, <code>replace</code>, <code>delete</code>, or <code>insert</code>.</p> <p>This looks like the following:</p> <pre><code>import jiwer\n\nout = jiwer.process_words(\"short one here\", \"shoe order one\")\nprint(out.alignments)\n# [[[AlignmentChunk(type='insert', ref_start_idx=0, ref_end_idx=0, hyp_start_idx=0, hyp_end_idx=1), ...]]\n</code></pre> <p>To visualize the alignment, you can use <code>jiwer.visualize_alignment()</code></p> <p>For example:</p> <p><pre><code>import jiwer\n\nout = jiwer.process_words(\n    [\"short one here\", \"quite a bit of longer sentence\"],\n    [\"shoe order one\", \"quite bit of an even longest sentence here\"],\n)\n\nprint(jiwer.visualize_alignment(out))\n</code></pre> Gives the following output <pre><code>sentence 1\nREF: **** short one here\nHYP: shoe order one ****\n        I     S        D\n\nsentence 2\nREF: quite a bit of ** ****  longer sentence ****\nHYP: quite * bit of an even longest sentence here\n           D         I    I       S             I\n\nnumber of sentences: 2\nsubstitutions=2 deletions=2 insertions=4 hits=5\n\nmer=61.54%\nwil=74.75%\nwip=25.25%\nwer=88.89%\n</code></pre></p> <p>Note that it also possible to visualize the character-level alignment, simply use the output of <code>jiwer.process_characters()</code> instead. </p>"}]}